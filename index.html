<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script>
// Final boss-level numberToCanonicalFGH -> HTML-only output (Option A)
function numberToCanonicalFGH(nInput, baseInput, options = {}) {
  const n = BigInt(nInput);
  const base = BigInt(baseInput);
  if (n < base) throw new Error("n must be >= base");

  const MAX_K = options.maxK ?? 12;               // limit search depth for k
  const MAX_EXPR_STRING = options.maxExprString ?? 20000; // truncate safety
  const MAX_F0_EXPAND = options.maxF0Expand ?? 1_000_000; // cap explicit f0 expansions

  // Memoization for f_k(x) results: key = `${k},${x}`
  const fkMemo = new Map();

  // compute f_k(x) but stop early if > limit.
  function compute_fk_lte_limit(k, x, limit) {
    k = Number(k);
    x = BigInt(x);
    limit = BigInt(limit);
    const key = `${k},${x}`;
    if (fkMemo.has(key)) return fkMemo.get(key);

    function store(res) { fkMemo.set(key, res); return res; }

    // f0: x + 1
    if (k === 0) {
      const v = x + 1n;
      return store(v > limit ? { exceeded: true } : { value: v, exceeded: false });
    }

    // f1: 2x
    if (k === 1) {
      const v = x << 1n;
      return store(v > limit ? { exceeded: true } : { value: v, exceeded: false });
    }

    // f2: x * 2^x
    if (k === 2) {
      if (x > 4096n) return store({ exceeded: true });
      const v = x * (1n << x);
      return store(v > limit ? { exceeded: true } : { value: v, exceeded: false });
    }

    // k >= 3: hyper-exponential; guard if x too big
    if (x > 32n) return store({ exceeded: true });

    // iterate applying f_{k-1} x times
    let v = x;
    for (let i = 0; i < Number(x); i++) {
      const lower = compute_fk_lte_limit(k - 1, v, limit);
      if (lower.exceeded) return store({ exceeded: true });
      v = lower.value;
      if (v > limit) return store({ exceeded: true });
    }
    return store({ value: v, exceeded: false });
  }

  // ---------- Expression representation ----------
  function baseNode(v) { return { type: "base", v: BigInt(v), hash: `B${v.toString()}` }; }
  function fNode(k, inner) { return { type: "f", k: Number(k), inner, hash: `F${k},${inner.hash}` }; }

  // Evaluate symbolic expression to a numeric value <= limit
  const evalMemo = new Map();
  function evalExprLimited(expr, limit) {
    const limitBig = BigInt(limit);
    const memoKey = expr.hash + '|' + limitBig.toString();
    if (evalMemo.has(memoKey)) return evalMemo.get(memoKey);

    // flatten frames
    const frames = [];
    let cur = expr;
    while (cur.type !== "base") {
      if (cur.type === "f") {
        frames.push({ k: cur.k });
        cur = cur.inner;
      } else {
        throw new Error("Unknown expr node type: " + JSON.stringify(cur));
      }
    }

    let value = cur.v;
    for (let i = frames.length - 1; i >= 0; i--) {
      const r = compute_fk_lte_limit(frames[i].k, value, limitBig);
      if (r.exceeded) {
        const res = { exceeded: true };
        evalMemo.set(memoKey, res);
        return res;
      }
      value = r.value;
    }
    const res = { value: value, exceeded: false };
    evalMemo.set(memoKey, res);
    return res;
  }

  // ---------- Core canonical builder (greedy) ----------
  let expr = baseNode(base);
  if (base === n) return base.toString();

  while (true) {
    const ev = evalExprLimited(expr, n);
    if (!ev.exceeded && ev.value === n) break;
    if (ev.exceeded) throw new Error("evaluation exceeded unexpectedly for current expression");

    const currentVal = ev.value; // numeric value < n

    // find largest k (0..MAX_K) such that f_k(currentVal) <= n
    let chosenK = -1;
    for (let k = 0; k <= MAX_K; k++) {
      const r = compute_fk_lte_limit(k, currentVal, n);
      if (!r.exceeded) chosenK = k;
      else break;
    }
    if (chosenK === -1) throw new Error("Cannot find any f_k that keeps value <= n (unexpected).");

    if (chosenK === 0) {
      const diff = n - currentVal;
      if (diff < 0n) throw new Error("negative difference (bug)");
      if (diff > BigInt(MAX_F0_EXPAND)) {
        throw new Error(
          `Difference ${diff.toString()} is too large to expand as explicit F<sub>0</sub>(...) wrappers without compression. ` +
          `Increase maxF0Expand if you understand the implications.`
        );
      }
      const times = Number(diff);
      for (let i = 0; i < times; i++) expr = fNode(0, expr);

      const finalEval = evalExprLimited(expr, n);
      if (!finalEval.exceeded && finalEval.value === n) break;
      throw new Error("failed to reach n after applying explicit F<sub>0</sub> wrappers");
    }

    // wrap once with chosenK >= 1
    expr = fNode(chosenK, expr);

    // guard: if string would be enormous, abort with truncated text
    const sTest = exprToStringWithoutConversion(expr);
    if (sTest.length > MAX_EXPR_STRING) {
      return sTest.slice(0, MAX_EXPR_STRING) + "...(truncated)";
    }
  }

  // Now we have expr that evaluates to n. Build raw HTML-ish string (numbers not rewritten yet).
  const raw = exprToStringWithoutConversion(expr);

  // Post-process: rewrite numeric literals > base (except base itself) into canonical FGH recursively.
  return rewriteNumbersOutsideTags(raw, base);

  // -------------------------
  // String builders & helpers
  // -------------------------

  // formatF: produces HTML string for F_k (with optional superscript run)
  function formatF(k, run, inner) {
    if (run > 1) {
      return `F<sub>${k}</sub><sup>${run}</sup>(${inner})`;
    }
    return `F<sub>${k}</sub>(${inner})`;
  }

  // Build string from expr WITHOUT converting numbers to FGH — numbers remain as digits.
  function exprToStringWithoutConversion(expr) {
    const frames = [];
    let cur = expr;
    while (cur.type !== "base") {
      frames.push(cur.k);
      cur = cur.inner;
    }

    let s = cur.v.toString();

    for (let i = frames.length - 1; i >= 0; ) {
      const k = frames[i];
      let run = 1;
      let j = i - 1;
      while (j >= 0 && frames[j] === k) { run++; j--; }

      // If run > base collapse into F_k^run(...), else produce repeated F_k(...) explicitly
      if (run > Number(base)) {
        s = formatF(k, run, s);
      } else {
        for (let t = 0; t < run; t++) s = formatF(k, 1, s);
      }
      i = j;

      if (s.length > MAX_EXPR_STRING) return s.slice(0, MAX_EXPR_STRING) + "...(truncated)";
    }
    return s;
  }

  // Rewrite numbers only outside of HTML tags.
  // We split the string by tags and only replace numbers in non-tag parts.
  function rewriteNumbersOutsideTags(str, baseVal) {
    const b = BigInt(baseVal);

    // Split keeping tags: any "<...>" is a separate token.
    // This preserves tags like <sub>2</sub> so we don't rewrite the 2 inside them.
    const parts = str.split(/(<[^>]+>)/g);

    for (let p = 0; p < parts.length; p++) {
      const piece = parts[p];
      if (!piece || piece[0] === "<") {
        // it's a tag — do not modify
        continue;
      }

      // replace numbers in this plain-text piece
      parts[p] = piece.replace(/\b\d+\b/g, (m) => {
        const x = BigInt(m);
        if (x === b) return m;   // keep base literal unchanged
        if (x < b) return m;     // keep smaller numbers unchanged
        // For numbers > base: recursively obtain canonical HTML string.
        // This is safe because the recursive call will produce HTML with tags;
        // it will be inserted into the current output as a chunk.
        return numberToCanonicalFGH(x, b, options);
      });
    }

    return parts.join("");
  }
}



// ----------------- Example tests -----------------
let i = 2;              // start as Number
const threshold = 2 ** 53 - 1;    // max safe integer for double
const factor = 1.001;

setInterval(() => {
  // If still safe: use Number
  if (typeof i === "number") {
    i *= factor;

    // When exceeding safe integer → convert to BigInt
    if (i > threshold) {
      i = BigInt(Math.floor(i));
    }
  } 
  else {
    // Already BigInt: multiply using scaled integer math
    // factor = 1.25 = 5/4
    i = (i * 100n) / 99n;
  }

  const displayValue =
    typeof i === "number" ? i : i.toString();

  document.getElementById("i").innerHTML = "i = " + Math.floor(displayValue);

  // Always call your function with BigInt-rounded value
  const bigintForFunction =
    typeof i === "number"
      ? BigInt(Math.floor(i))
      : i;

  document.getElementById("output").innerHTML =
    numberToCanonicalFGH(bigintForFunction, 2n);

}, 10);

    </script>
</head>
<body>
    <h1>FGH Lngi v1</h1>
    <h4 id = "i">i = 0</h4>
    <p id="output" style="white-space: normal; word-wrap: break-word;">
        f0(0)
    </p>

</body>
</html>
